worker_processes auto;
worker_cpu_affinity auto;
worker_shutdown_timeout 10s;

events {
	worker_connections 4096;
	use epoll;
}

http {
	include media_types.conf;
	include character_encodings.conf;

	sendfile   on;
	tcp_nopush on;

	include compression.conf;

	map $http_x_forwarded_proto $fcgi_https {
		default off;
		http    off;
		https   on;
	}

	upstream php-handler {
		server app:9000;
	}

	server {
		listen 80;

		root /var/www/html;

		client_max_body_size 0;

		# HTTP response headers borrowed from Nextcloud `.htaccess`
		add_header Referrer-Policy                   "no-referrer"   always;
		add_header X-Content-Type-Options            "nosniff"       always;
		add_header X-Download-Options                "noopen"        always;
		add_header X-Frame-Options                   "SAMEORIGIN"    always;
		add_header X-Permitted-Cross-Domain-Policies "none"          always;
		add_header X-Robots-Tag                      "none"          always;
		add_header X-XSS-Protection                  "1; mode=block" always;

		# Remove X-Powered-By, which is an information leak
		fastcgi_hide_header X-Powered-By;

		# Specify how to handle directories -- specifying `/index.php$request_uri`
		# here as the fallback means that Nginx always exhibits the desired behaviour
		# when a client requests a path that corresponds to a directory that exists
		# on the server. In particular, if that directory contains an index.php file,
		# that file is correctly served; if it doesn't, then the request is passed to
		# the front-end controller. This consistent behaviour means that we don't need
		# to specify custom rules for certain paths (e.g. images and other assets,
		# `/updater`, `/ocm-provider`, `/ocs-provider`), and thus
		# `try_files $uri $uri/ /index.php$request_uri`
		# always provides the desired behaviour.
		index index.php index.html /index.php$request_uri;

		# Rule borrowed from `.htaccess` to handle Microsoft DAV clients
		# location = / {
		#     if ( $http_user_agent ~ ^DavClnt ) {
		#         return 302 /remote.php/webdav/$is_args$args;
		#     }
		# }

		location = /robots.txt {
			access_log off;
			allow all;
			log_not_found off;
		}

		location ^~ /.well-known {
			location = /.well-known/caldav  {
				return 301 $http_x_forwarded_proto://$host:$http_x_forwarded_port/remote.php/dav/;
			}

			location = /.well-known/carddav {
				return 301 $http_x_forwarded_proto://$host:$http_x_forwarded_port/remote.php/dav/;
			}

			return 301 $http_x_forwarded_proto://$host:$http_x_forwarded_port/index.php$request_uri;
		}

		location ~ ^(?:build|tests|config|lib|3rdparty|templates)/.* {
			return 404;
		}

		location ~ ^(?:\.(?!well-known)|autotest|occ|issue|indie|db_|console).* {
			return 404;
		}

		# Ensure this block, which passes PHP files to the PHP process, is above the blocks
		# which handle static assets (as seen below). If this block is not declared first,
		# then Nginx will encounter an infinite rewriting loop when it prepends `/index.php`
		# to the URI, resulting in a HTTP 500 error response.
		location ~ \.php(?:$|/) {
			# Required for legacy support
			# rewrite ^/(?!index|remote|public|cron|core\/ajax\/update|status|ocs\/v[12]|updater\/.+|oc[ms]-provider\/.+|.+\/richdocumentscode\/proxy) /index.php$request_uri;

			fastcgi_split_path_info ^(.+?\.php)(/.*)$;
			set $path_info $fastcgi_path_info;

			try_files $fastcgi_script_name =404;

			include fastcgi_params;
			fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
			fastcgi_param PATH_INFO $path_info;
			fastcgi_param HTTPS $fcgi_https;

			fastcgi_param modHeadersAvailable true;         # Avoid sending the security headers twice
			fastcgi_param front_controller_active true;     # Enable pretty urls
			fastcgi_pass php-handler;

			fastcgi_intercept_errors on;
			fastcgi_request_buffering off;

			fastcgi_buffers 64 4K;
			fastcgi_read_timeout 1d;
			fastcgi_send_timeout 1d;
		}

		location ~ \.(css|js|svg|gif|png|jpg|ico|wasm|tflite)$ {
			try_files $uri /index.php$request_uri;
			expires 15778463s;
		}

		location ~ \.woff2?$ {
			try_files $uri /index.php$request_uri;
			expires 604800s;
		}

		location /remote {
			return 301 /remote.php$request_uri;
		}

		location / {
			try_files $uri $uri/ /index.php$request_uri;
		}
	}
}
